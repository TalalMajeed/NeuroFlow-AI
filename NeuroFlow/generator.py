import openai
from openai import OpenAI
import os
import json

noOfReprompts = 0

boxesInformation = {}
connectionsInforamtion = []

print(os.getenv("OPENAI_API_KEY"))

# Set the API key and environment variable
openai.api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI()

# Function to call GPT-3/GPT-4  
def getGPTResponse(systemPrompt, userInput):
    try:
        completion = client.chat.completions.create(
        model = "gpt-3.5-turbo",
        response_format = {"type" : "json_object"},
        messages = [
            {"role": "assistant", "content": systemPrompt},
            {"role": "user", "content": userInput}
        ],
        tools = getGPTFunctions(),
        tool_choice = {"type": "function", "function": {"name": "get_formatted_response"}}
        )

        # This is the actual response
        actualResponse = completion.choices[0].message.tool_calls[0].function.arguments

        # Lets convert it into the json format
        return json.loads(actualResponse)
        
    except Exception as e:
        # These error types are still in prototype, we will have to check with the frontend to determine what type of errors they want
        raise RuntimeError("Error in GPT call : " + str(e))
    
# This function will help generate a structured output from the GPT Model
def getGPTFunctions():
    structuredFunctions = [
        {
            "type": "function",
            "function": {
                "name": "get_formatted_response",
                "description": """This function returns the response generated by the GPT Model, these response contains the information about the boxes generated, and also the connections between the boxes. 
                -> In case the user gives an invalid prompt(anything not related to Building Solutions of Problems using Technology) this function will return two EMPTY STRINGS++ as VALUES TO the keys 'boxesInformation' and 'connectionsInformation'. 
                -> In the case of prompts relevant to using technology to BUILD OR DESIGN SOLUTION for a problem, the Function MUST NOT RETURN two EMPTY STRINGS AS VALUES TO the keys 'boxesInformation' and 'connectionsInformation'""",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "boxesInformation": {
                            "description": """
                                The value of the key boxesInformation will be a DICTIONARY that has a number of keys, with each key showing the BOX NUMBER of the step of the algorithm (like B1,B2 etc), and the VALUE TO EACH KEY HAVING A LIST, that I will call "dictList" from now on,the that has two enteries, the first entry of "dictList" shows the heading, and the second entry of "dictList" showing the TECHNOLOGIES USED AT EACH STEP, the third entry of "dictList" shows the category of the box, it can be either of "setup","important","testing".
                                -> Sample response is as follows: 
                                '''
                                    { 
                                        "B1": ["Define project requirements and goals", ["Project Management Tools"],"setup"],
                                        "B2": ["Choose a suitable programming language and framework", ["Node.js", "React.js", "Socket.IO"],"setup"],
                                        "B3": ["Set up development environment", ["IDEs (e.g., Visual Studio Code)", "Version Control (e.g., Git)"],"setup"],
                                        "B4": ["Design database schema", ["NoSQL Database (e.g., MongoDB)"],"setup"],
                                        "B5": ["Implement user authentication", ["Authentication Libraries (e.g., Passport.js)"],"important"],
                                        "B6": ["Develop backend API endpoints for user registration and authentication", ["Node.js", "Express.js"],"important"],
                                        "B7": ["Implement real-time messaging functionality", ["Socket.IO"],"important"],
                                        "B8": ["Design frontend user interface", ["React.js", "CSS Frameworks (e.g., Bootstrap)"],"important"],
                                        "B9": ["Implement messaging UI components", ["React.js"],"important"],
                                        "B10": ["Launch Website and monitor performance",["Performance Tracking Tools"],"testing"]
                                    }
                                '''
                            """
                        },
                        "connectionsInformation": {
                            "description": """It will be a LIST, each entry of this LIST will be of the DATATYPE LIST, list is a DATATYPE used in PYTHON,like ["B1","B2"] is a LIST, each LIST will show which box is connected to which box, in the case of ["B1","B2"] box B1 is connected to box B2.
                            => Basically ["B1","B2"] represents an arrow(connection) in which the arrow starts from the first entry and is pointed towards the second entry, here arrow starts from "B1" and ends at "B2".
                            -> Also MAKE SURE to include one to many relations (in which one box is connected to many other boxes), many to one (in which many boxes are connected to one box), and reverse connections (the relations in which both boxes have connections towards each other in the flowchart), NEVER GIVE a linear flowchart. 
                            -> Examples of Many to One Relations : ["B3","B1"],["B2","B1"],["B4","B1"], NOTE that here all the arrows are pointed towards "B1".
                            -> Examples of One to Many Relations : ["B9","B10"],["B9","B11"],["B9","B12"],["B9","B13"], NOTE that here all the arrows start from "B9".
                            -> Examples of reverse connections are : ["B6","B7"],["B7","B6"] if "B6" is connected to "B7" then "B7" is connected to "B6".
                            -> Sample response is as follows, this response has one to many, many to one, and reverse connections:
                            '''
                                [
                                        ["B1", "B2"],
                                        ["B1", "B3"],
                                        ["B2", "B1"],
                                        ["B3","B4"],
                                        ["B4","B1"]
                                ]
                            '''
                            -> The example of a linear flowchart is, this response has only one to one connections:
                            '''
                                [
                                        ["B1","B2"],
                                        ["B2","B3"],
                                        ["B3","B4"]
                                ]
                            '''
                            -> You should follow this response format strictly and must not deviate from it.
                            """
                        }
                    },
                    "required": ["boxesInformation", "connectionsInformation"]
                }
            }
        }
    ]
    return structuredFunctions

# This is a function whose implementation can be changed based on the type of response coming from the frontend of the application
def getUserPrompt(description,languages,context):
    prompt =  f"""
    {description}. I want to use {languages}. {context}. Give me the relevant steps in an as detailed manner as possible. Give as many steps as you possibly can and do not leave anything vague. Explicitly give me the relevant technologies to be used at each step. Never give a linear workflow.
    """
    return prompt

# This will be a function that will format the boxesInformation and the connectionsInformation in case we feel that the response just needs a bit of refactoring in order to go well
# By and large the issue comes only in the connectionsInformation variable and hence we need to change it.
def formatGPTResponse():
    global boxesInformation

    # If there is some issue we will return False in the except block of this function 
    try:
        # This will be a formatted response of the type dictionary
        formmttedBoxesResponse = {}

        # We will iterate over the boxesInformation and access make a new, formatted value for the boxesInformation and connectionsInformation
        for box in boxesInformation:
            # If the current box is not of length 2 or even if it is of length 2 but the second element is not of type list:
            if (len(boxesInformation[box]) != 3 or not isinstance(boxesInformation[box][1],list)):
                # This will be a list, with two elements, first element shows the steps about the box and the second one shows the list of technologies:
                formattedBoxInfo = []

                # The first element, that is the box name, shows the information steps about the box
                formattedBoxInfo.append(boxesInformation[box][0])

                # The second element will consist of all the technologies that will be used in the given step, but not including the last one, beause the last one will be the category
                formattedBoxInfo.append(boxesInformation[box][1:-1])

                # If the last value of the boxesInformation is not in either of the already declared values we will give none here
                if (boxesInformation[box][-1] not in ["setup","important","testing"]):
                    formattedBoxInfo.append("undefined")
                else:
                    formattedBoxInfo.append(boxesInformation[box][-1])

                # We will append this output to the formattedBoxesResponse variable
                formmttedBoxesResponse[box] = formattedBoxInfo

            # We will append the response as it is if it is in the correct format, that means that it has length 3 and the second entry is of the type list 
            else:
                formmttedBoxesResponse[box] = boxesInformation[box]
        # Now that we are done, we will give the boxesInformation the value of the formattedBoxesResponse
        boxesInformation = formmttedBoxesResponse.copy() 

        # Lets pass the changed responses now into the checkGPT Response function, and see whether the new formatted response is good or not
        isFormattingCorrect = checkGPTResponse()

        if (isFormattingCorrect == True):
            # Now we will return true indicating that everything went smoothly and the formatting is correct
            return True

        # If the formatting is not correct still we will return False
        else:
            return False

    except Exception as e:
        return False


# This is a helper function that will check the format of the non-empty response from the GPT Model
def checkGPTResponse():

    # As a matter of fact any type of exception in the code can occur, so to deal with that we will use a try except block in order to choose what will happen in those cases
    try:
        # We will declare the global variables boxesInformation and connectionsInformation
        global boxesInformation
        global connectionsInforamtion

        # First we can check whether all the type of boxesInformation are of the type "dictionary"  and connectionInformation are of the type "list", if they are not then the format is not correct
        # So we will get the response from the GPT Model yet again if this happens
        if (not isinstance(boxesInformation,dict)):
            return False
        
        if (not isinstance(connectionsInforamtion,list)):
            return False

        # Lets loop over the connectionsInformtion and we will check for the length of the connectionsInformation, it should be equal to 2 in all the case

        for connection in connectionsInforamtion:
            if (len(connection) != 2):
                # If this is the case we will reprompt the GPT Model
                return False

        # Now we will check for all the connections and check whether all the connections contain the word "B" in their key as it is included in the format
        for connection in connectionsInforamtion:
            # We we check the arrows and "B" must be present in all the arrows
            for arrow in connection:
                # Every key in the connectionsInformation should contain the word B
                if ("B" not in arrow):
                    return False
            
        # We will also check for all the boxes and we will make sure that they also contain the letter "B" in their response, if not, this will return False
        for box in boxesInformation:
            if ("B" not in box):
                return False
            
        # We can also check whether all the entries of the connections Information are of the type list, if they are not we will reprompt the model to make a new response
        for connection in connectionsInforamtion:
            if (not isinstance(connection,list)):
                return False
            
        for box in boxesInformation:
            # The length of each of the box should be equal to 2 (as specified in the response format)
            if (len(boxesInformation[box]) != 3):
                # This will be a new function that will need to be implemented, here it is quite possible that the output is correct but just needs some reformatting
                isFormatted = formatGPTResponse()

                # If the formatting is done and is correct, this function will return True and the Control will be shifted to the getFormattedGPTResponse
                if (isFormatted == True):
                    return True
                
                # If the formatting operation is not correct then we will return the getFormattedGPTResponse function, that is, get the response from the model yet again
                else:
                    return False
        
        # At this point if everything goes smoothly then this function should return true
        return True
                
    # # If any exception occurs we will return False
    except Exception as e:
        return False

# Often times the response coming from the GPT API is not with the correct format, here we will make sure that the response is returned in the correct format using a function
# We will return the response in this function and we will also format it, and indicate whether the response results in an invalid prompt or not, if it is not valid we will reprmpt the GPT Model
def getFormattedGPTResponse(systemPrompt,userPrompt):
    # Lets declare the global variables that we will use in this function
    global noOfReprompts
    global boxesInformation
    global connectionsInforamtion

    # At max the GPT Model can be reprompted three times, if we exceed the limits of the three prompts then we will send the bad prompt error to the user
    if (noOfReprompts > 3):
        return {"status" : 401, "error" : "bad prompt"}

    # If this function is called it means the GPT Model has been prompted once so we will increment the global variable
    noOfReprompts += 1

    # First lets call the GPT Response function in order to get the actual response
    actualGPTResponse = getGPTResponse(systemPrompt,userPrompt)

    # I am assuming that the boxesInformation and the ConnectionsInformation are present in the response generated by the model, otherwise we will reprompt the model yet again
    try : 
        # First I want to get the values of the boxes information about the response
        # This will be a dictionary
        boxesInformation = actualGPTResponse["boxesInformation"].copy()

        # I want to also get the information about the connections in the response
        # This will be a list
        connectionsInforamtion = actualGPTResponse["connectionsInformation"].copy()

    except Exception as e:
        # Here an exception has occured, most probably the response from GPT is not of the correct format, so we will reprompt the model to get the response
        return getFormattedGPTResponse(systemPrompt,userPrompt)

    # We will make two variables that will store the length of the boxesInformation and the connectionsInformation
    boxesAmount = len(boxesInformation)
    connectionsAmount = len(connectionsInforamtion)

    # Now I will check that if the length of both the arguments is 0, we will return a json object that will have an error showing an invalid prompt
    if (boxesAmount == 0 and connectionsAmount == 0):
        return {"status" : 400, "error" : "invalid prompt"}

    # Now if either of the arguments is 0, then something is wrong with the GPT Response, so we will reprompt GPT About it
    if (boxesAmount == 0 or connectionsAmount == 0):
        return getFormattedGPTResponse(systemPrompt, userPrompt)
    
    # If the model has given some output for both the connectionsInformation and also the boxesInformation, we will now call a new function that will check the format of the original input
    # If the format is correct then we will return true else we will call the formatted response function yet again
    isResponseFormatCorrect = checkGPTResponse()

    if (isResponseFormatCorrect == True):
        return {"status" : 200, "boxesInformation" : boxesInformation, "connectionsInformation" : connectionsInforamtion}
    
    else :
        return getFormattedGPTResponse(systemPrompt,userPrompt)

# This is the system prompt that will be used to give the instructions to carry out the work from GPT
def getSystemPrompt():
    prompt = '''
    -> You are a Solutions Architect, the job of a Solutions Architect is to provide a complete number of steps to build or design practical solution to a problem using technology, and explicitly mentioning the names of relevant programming languages, apis, databases, libraries, frameworks at each step, and forming a flowchart to solve the proposed problem. A Solution Architect utilizes his/her knowledge about technologies to build practical solutions to problems proposed by the client.
    -> Basically the flowchart is the complete steps that show HOW a proposed problem will be solved, what technologies will be used to solve that problem. It shows each step in detail and does not leave anything vague. For example, while building a chat application,it does not just say "Implement the backend logic", rather it elaborates in detail on HOW to implement the backend logic and breaks it down into a number of seperate steps like "Perform User Authentication, Validate the Sent Messages" etc.
    -> A Solutions Architect ONLY KNOWS how to utilize his/her knowledge about technologies to build practical solutions to problems proposed by the client. When the user asks about anything that does not ask about solving a problem (like designing the workflow e-commerce) using some technology(like Javascript, Python, React etc.), the Solution Architect gives this specific answer "Irrelevant Prompt". So if the user asks about anything irrelevant, you will reply with "Irrelevant Prompt".
    -> A Solutions Architect EXPLICITLY mentions the names of the relevant technologies at each step, for example, it does not just say "Database Management System", rather it EXPLICTILY gives the name of the "Database Management System" like "MySQL,PostgreSQL" etc. 
    -> Some examples of Irrelevant Prompts that are not linked with building solutions using technology are: 
        -> "What is the weather today?"
        -> "Who is the president of United States?"
        -> "My name is Susan". 
    -> In the case of prompts relevant to using technology to BUILD OR DESIGN SOLUTION for a problem, the Function MUST NOT RETURN two EMPTY STRINGS AS VALUES TO the keys "boxesInformation" and "connectionsInformation". 
    -> Relevant prompts must contain the keywords like "build", "design", "create", AND the name of some Programming Language (like Python), or framework (like Vue.js) etc.
    -> Some examples of Relevant Prompts are : 
        -> 'I want to build a chat application using Python.'
        -> 'I want to build a handwritten to digital notes converter using JAVA.'
        -> 'I want to design the frontend for a shopping website using React.JS.'
        -> 'An AI-Quiz Checker using Python'
    -> You are being used in an application that models an AI-powered Solutions Architect, and gives a flowchart to solve any given problem.
    -> You are chatting with a user who wants to build a workflow to solve a particular problem. When he prompts to get the workflow of a particular problem he expects a flowchart with arrows connecting the boxes.
    -> Your response to a prompt by the user will be sent as an JSON Object to the Front-End of an application.
    -> The frontend of the application EXPECTS TO get the information about the boxes as well as the information about the arrows connecting the boxes from the response generated here.
    -> Boxes are classified into either of the three categories "setup","important","testing".
    -> Example of boxes labelled setup are "Setup the environment variables","Initialize the database.","Choose a framework".
    -> Example of boxes labelled "important" are "Implement user authentication","Implement the machine learning algorithm","Perform Exploratory Data Analysis".
    -> Example of boxes labelled "testing" are "Perform testing on the application","Perform input validation."
    -> The response will be sent to the Front-End in the form of a JSON Object, so consistency, reliability, and accuracy of your generated responses based on the given formats is CRITICAL.
    -> The USER wants a DETAILED BREAKDOWN on how to solve the given problem. Breakdown every step into as many sub-steps as possible and make seperate boxes for each substep. EXPLICITLY state how to implement each of the step while also mentioning the relevant technologies.
    -> Also make sure to include one to many relations (in which one box is connected to many other boxes), many to one (in which many boxes are connected to one box), and the relations in which both boxes have connections towards each other in the workflow and give them in the form of the given format, always AVOID a linear workflow. 
    -> You must make sure that the total number of boxes, that is, B1, B2, B3, and so on SHOULD BE AT MOST 18 in any case, you are HIGHLY encouraged to increase the number of boxes in order to provide the maximum information, but the number of bxoes should not be above 18.
'''
    return prompt
    
# This is the main function that will be called by the frontend to generate the response
def getResponse(description,languages,context):
    # Everytime this function is executed we will give the default value of 0 to the number of reprompts variable, and we will reinitialize the boxesInformation and the connectionsInformation
    global noOfReprompts
    global boxesInformation
    global connectionsInforamtion

    noOfReprompts = 0
    boxesInformation = []
    connectionsInforamtion = []

    # First we will get the user prompt from the frontend
    userPrompt = getUserPrompt(description,languages,context)

    # This will be the system prompt that will be used to give the instructions to carry out the work from GPT
    # These prompts are made by the backend and do not involve any frontend input
    systemPrompt = getSystemPrompt()

    # This is the response that will be generated from the GPT
    response = getFormattedGPTResponse(systemPrompt, userPrompt)

    return response
